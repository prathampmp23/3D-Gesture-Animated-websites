<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand-Controlled Solar System</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: "Segoe UI", sans-serif;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 10px;
        pointer-events: none;
        border: 1px solid #444;
        z-index: 100;
      }
      #info-card {
        position: absolute;
        bottom: 20px;
        right: 20px;
        color: #00ffcc;
        background: rgba(0, 20, 40, 0.8);
        padding: 20px;
        border-radius: 10px;
        display: none;
        border: 1px solid #00ffcc;
        width: 250px;
      }
      #input_video {
        display: none;
      }
      canvas {
        display: block;
      }
      .gesture-hint {
        font-size: 0.8em;
        color: #00ffcc;
        margin-top: 5px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div id="status">Initializing AI...</div>
      <div class="gesture-hint">
        • <b>Pinch Index + Thumb:</b> Zoom In/Out<br />
        • <b>Move Palm:</b> Rotate System<br />
        • <b>Open 5 Fingers:</b> Toggle Speed<br />
        • <b>Point Index:</b> Focus Planet
      </div>
    </div>

    <div id="info-card">
      <h2 id="planet-name">Planet</h2>
      <p id="planet-details"></p>
    </div>

    <video id="input_video"></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      // --- CONFIGURATION ---
      const PLANET_DATA = [
        { name: "Mercury", color: 0xaaaaaa, dist: 15, size: 0.8, speed: 0.04 },
        { name: "Venus", color: 0xffccaa, dist: 22, size: 1.2, speed: 0.015 },
        { name: "Earth", color: 0x2233ff, dist: 30, size: 1.3, speed: 0.01 },
        { name: "Mars", color: 0xff5522, dist: 38, size: 1.0, speed: 0.008 },
        { name: "Jupiter", color: 0xffaa88, dist: 55, size: 3.5, speed: 0.004 },
        {
          name: "Saturn",
          color: 0xddccaa,
          dist: 75,
          size: 3.0,
          speed: 0.002,
          rings: true,
        },
        { name: "Uranus", color: 0x88ccff, dist: 90, size: 2.0, speed: 0.001 },
        {
          name: "Neptune",
          color: 0x3366ff,
          dist: 105,
          size: 2.0,
          speed: 0.0008,
        },
      ];

      let scene, camera, renderer, sun, starField;
      let planets = [];
      let timeScale = 1;
      let targetRotation = { x: 0.5, y: 0 };
      let zoomLevel = 80;

      // --- THREE.JS INIT ---
      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Sun (Light Source)
        const sunGeo = new THREE.SphereGeometry(6, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);

        const solarLight = new THREE.PointLight(0xffffff, 1000, 500);
        scene.add(solarLight);
        scene.add(new THREE.AmbientLight(0x222222));

        // Create Planets
        PLANET_DATA.forEach((data) => {
          const orbitGroup = new THREE.Group();

          // Planet Mesh
          const pGeo = new THREE.SphereGeometry(data.size, 32, 32);
          const pMat = new THREE.MeshStandardMaterial({
            color: data.color,
            roughness: 0.7,
          });
          const pMesh = new THREE.Mesh(pGeo, pMat);
          pMesh.position.x = data.dist;

          // Rings for Saturn
          if (data.rings) {
            const rGeo = new THREE.RingGeometry(
              data.size + 1,
              data.size + 3,
              64
            );
            const rMat = new THREE.MeshBasicMaterial({
              color: 0x887766,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.6,
            });
            const rMesh = new THREE.Mesh(rGeo, rMat);
            rMesh.rotation.x = Math.PI / 2;
            pMesh.add(rMesh);
          }

          // Orbital Path (Circle)
          const pathGeo = new THREE.RingGeometry(
            data.dist - 0.1,
            data.dist + 0.1,
            128
          );
          const pathMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.1,
            side: THREE.DoubleSide,
          });
          const pathMesh = new THREE.Mesh(pathGeo, pathMat);
          pathMesh.rotation.x = Math.PI / 2;
          scene.add(pathMesh);

          orbitGroup.add(pMesh);
          scene.add(orbitGroup);
          planets.push({
            group: orbitGroup,
            mesh: pMesh,
            data: data,
            angle: Math.random() * Math.PI * 2,
          });
        });

        // Asteroid Belt
        const asteroids = new THREE.InstancedMesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.2),
          new THREE.MeshStandardMaterial({ color: 0x888888 }),
          500
        );
        const dummy = new THREE.Object3D();
        for (let i = 0; i < 500; i++) {
          const r = 42 + Math.random() * 6;
          const a = Math.random() * Math.PI * 2;
          dummy.position.set(
            Math.cos(a) * r,
            (Math.random() - 0.5) * 1,
            Math.sin(a) * r
          );
          dummy.updateMatrix();
          asteroids.setMatrixAt(i, dummy.matrix);
        }
        scene.add(asteroids);

        // Starfield
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for (let i = 0; i < 5000; i++) {
          starPos.push(
            (Math.random() - 0.5) * 1000,
            (Math.random() - 0.5) * 1000,
            (Math.random() - 0.5) * 1000
          );
        }
        starGeo.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(starPos, 3)
        );
        scene.add(
          new THREE.Points(
            starGeo,
            new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 })
          )
        );
      }

      // --- GESTURE LOGIC ---
      function onHandResults(results) {
        const status = document.getElementById("status");
        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          status.innerText = "Control Active";
          const lm = results.multiHandLandmarks[0];

          // 1. Rotation (Based on Palm / Middle Finger Base - Landmark 9)
          targetRotation.y = (lm[9].x - 0.5) * Math.PI * 2;
          targetRotation.x = (lm[9].y - 0.5) * Math.PI;

          // 2. Pinch Detection (Index Tip 8 vs Thumb Tip 4)
          const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
          if (pinchDist < 0.05) {
            zoomLevel = THREE.MathUtils.lerp(zoomLevel, 30, 0.1); // Zoom In
          } else if (pinchDist > 0.15) {
            zoomLevel = THREE.MathUtils.lerp(zoomLevel, 150, 0.05); // Zoom Out
          }

          // 3. Time Warp (Finger Counting)
          let upFingers = 0;
          [8, 12, 16, 20].forEach((tip) => {
            if (lm[tip].y < lm[tip - 2].y) upFingers++;
          });
          timeScale = upFingers === 4 ? 5 : 1; // 4 fingers = high speed
        } else {
          status.innerText = "Searching for Hand...";
        }
      }

      // --- MEDIAPIPE SETUP ---
      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
      });
      hands.onResults(onHandResults);

      const videoElement = document.getElementById("input_video");
      const cameraHelper = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480,
      });
      cameraHelper.start();

      // --- ANIMATION ---
      function animate() {
        requestAnimationFrame(animate);

        // Orbit planets
        planets.forEach((p) => {
          p.angle += p.data.speed * timeScale;
          p.group.rotation.y = p.angle;
          p.mesh.rotation.y += 0.02; // Self-rotation
        });

        // Camera Lerping
        camera.position.x +=
          (Math.sin(targetRotation.y) * zoomLevel - camera.position.x) * 0.05;
        camera.position.z +=
          (Math.cos(targetRotation.y) * zoomLevel - camera.position.z) * 0.05;
        camera.position.y += (targetRotation.x * 50 - camera.position.y) * 0.05;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }

      init();
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
