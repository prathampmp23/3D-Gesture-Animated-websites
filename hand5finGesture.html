<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture Shape Morpher</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: "Segoe UI", sans-serif;
      }
      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.6);
        padding: 20px;
        border-radius: 12px;
        backdrop-filter: blur(8px);
        z-index: 10;
        pointer-events: none;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      #input_video {
        display: none;
      }
      .status {
        color: #00ffcc;
        font-weight: bold;
        text-transform: uppercase;
      }
      .hint {
        font-size: 0.8em;
        color: #aaa;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <div id="status" class="status">Loading AI...</div>
      <div id="shape-name" style="font-size: 1.5em; margin: 5px 0">
        Shape: Sphere
      </div>
      <div class="hint">
        1: Sphere | 2: Saturn | 3: Heart | 4: Flower | 5: Explode
      </div>
    </div>

    <video id="input_video" autoplay playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      let scene, camera, renderer, particles, positions, velocities, colors;
      const particleCount = 10000;
      let targetX = 0,
        targetY = 0;
      let currentShape = "sphere";

      function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 20;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const geo = new THREE.BufferGeometry();
        positions = new Float32Array(particleCount * 3);
        velocities = new Float32Array(particleCount * 3);
        colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 40;
          positions[i * 3 + 1] = (Math.random() - 0.5) * 40;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
          setParticleColor(i, 0.5, 0.8, 1.0);
        }

        geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const mat = new THREE.PointsMaterial({
          size: 0.07,
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          transparent: true,
          opacity: 0.8,
        });

        particles = new THREE.Points(geo, mat);
        scene.add(particles);
      }

      function setParticleColor(i, r, g, b) {
        colors[i * 3] = r;
        colors[i * 3 + 1] = g;
        colors[i * 3 + 2] = b;
      }

      // --- MATHEMATICAL SHAPES ---
      function getShapePos(i, type) {
        let x, y, z;
        if (type === "heart") {
          const t = (i / particleCount) * Math.PI * 2;
          x = 12 * Math.pow(Math.sin(t), 3);
          y =
            10 * Math.cos(t) -
            4 * Math.cos(2 * t) -
            2 * Math.cos(3 * t) -
            Math.cos(4 * t);
          z = (Math.random() - 0.5) * 3;
          return { x: x * 0.6, y: y * 0.6, z: z };
        } else if (type === "saturn") {
          if (i < particleCount * 0.6) {
            // Planet
            const phi = Math.acos(-1 + (2 * i) / (particleCount * 0.6));
            const theta = Math.sqrt(particleCount * 0.6 * Math.PI) * phi;
            return {
              x: 5 * Math.cos(theta) * Math.sin(phi),
              y: 5 * Math.sin(theta) * Math.sin(phi),
              z: 5 * Math.cos(phi),
            };
          } else {
            // Rings
            const angle = Math.random() * Math.PI * 2;
            const r = 7 + Math.random() * 4;
            return {
              x: r * Math.cos(angle),
              y: r * Math.sin(angle) * 0.2,
              z: r * Math.sin(angle),
            };
          }
        } else if (type === "flower") {
          const t = (i / particleCount) * Math.PI * 2;
          const r = 8 * Math.cos(5 * t); // 5 petals
          return {
            x: r * Math.cos(t),
            y: r * Math.sin(t),
            z: (Math.random() - 0.5) * 2,
          };
        } else {
          // Sphere
          const phi = Math.acos(-1 + (2 * i) / particleCount);
          const theta = Math.sqrt(particleCount * Math.PI) * phi;
          return {
            x: 8 * Math.cos(theta) * Math.sin(phi),
            y: 8 * Math.sin(theta) * Math.sin(phi),
            z: 8 * Math.cos(phi),
          };
        }
      }

      // --- GESTURE LOGIC ---
      function updateGesture(landmarks) {
        const fingerTips = [8, 12, 16, 20];
        const fingerPips = [6, 10, 14, 18];
        let upCount = 0;

        // Check 4 fingers
        for (let i = 0; i < 4; i++) {
          if (landmarks[fingerTips[i]].y < landmarks[fingerPips[i]].y)
            upCount++;
        }
        // Check thumb separately
        if (landmarks[4].x < landmarks[3].x) upCount++;

        const shapeUI = document.getElementById("shape-name");
        if (upCount === 1) {
          currentShape = "sphere";
          shapeUI.innerText = "Shape: Sphere";
        }
        if (upCount === 2) {
          currentShape = "saturn";
          shapeUI.innerText = "Shape: Saturn";
        }
        if (upCount === 3) {
          currentShape = "heart";
          shapeUI.innerText = "Shape: Heart";
        }
        if (upCount === 4) {
          currentShape = "flower";
          shapeUI.innerText = "Shape: Flower";
        }
        if (upCount === 5) {
          shapeUI.innerText = "Action: EXPLODE!";
          for (let i = 0; i < particleCount * 3; i++) {
            velocities[i] += (Math.random() - 0.5) * 2;
          }
        }
      }

      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      hands.onResults((results) => {
        const status = document.getElementById("status");
        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          status.innerText = "Tracking Hand";
          const lm = results.multiHandLandmarks[0];
          targetX = (lm[9].x - 0.5) * -40; // Mirror X
          targetY = (lm[9].y - 0.5) * -30;
          updateGesture(lm);
        } else {
          status.innerText = "No Hand Detected";
        }
      });

      const cam = new Camera(document.getElementById("input_video"), {
        onFrame: async () => {
          await hands.send({ image: document.getElementById("input_video") });
        },
        width: 640,
        height: 480,
      });
      cam.start();

      function animate() {
        requestAnimationFrame(animate);
        const posArr = particles.geometry.attributes.position.array;
        const colorArr = particles.geometry.attributes.color.array;

        for (let i = 0; i < particleCount; i++) {
          const target = getShapePos(i, currentShape);

          // Move to Target + Hand Position
          posArr[i * 3] +=
            (target.x + targetX - posArr[i * 3]) * 0.08 + velocities[i * 3];
          posArr[i * 3 + 1] +=
            (target.y + targetY - posArr[i * 3 + 1]) * 0.08 +
            velocities[i * 3 + 1];
          posArr[i * 3 + 2] +=
            (target.z - posArr[i * 3 + 2]) * 0.08 + velocities[i * 3 + 2];

          // Slow down velocities
          velocities[i * 3] *= 0.92;
          velocities[i * 3 + 1] *= 0.92;
          velocities[i * 3 + 2] *= 0.92;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
      }

      initThree();
      animate();
    </script>
  </body>
</html>
